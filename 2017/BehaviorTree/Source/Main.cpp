#include "ETF1.h"
#include "BehaviorTree.h"

enum TestEnum
{
  Zero,
  One,
  Two,
  Three
};

struct MediumData
{
  TestEnum *SmallData;
  TestEnum *LargeData;
};

int SmallTestFunction( void *Data )
{
  std::cout << "SmallTop" << std::endl;

  auto TestData =static_cast< TestEnum* >( Data );

  if( *TestData >= One )
  {
    return *TestData - 1;
  }

  return BehaviorTreeSpace::Prev;
}

int MediumTestFunction( void *Data )
{
  std::cout << "MediumTop" << std::endl;

  auto TestData = static_cast< TestEnum* >( Data );

  if( *TestData >= One )
  {
    return *TestData - 1;
  }

  return BehaviorTreeSpace::Prev;
}

int MediumLargeTestFunction( void *Data )
{
  std::cout << "MediumLargeTop" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  if( *TestData->SmallData >= One )
  {
    return *TestData->SmallData - 1;
  }

  --( *( ( int * )TestData->LargeData ) );

  return BehaviorTreeSpace::Prev;
}

int LargeTestFunction( void *Data )
{
  std::cout << "LargeTop" << std::endl;

  auto TestData = static_cast< TestEnum* >( Data );

  if( *TestData >= One )
  {
    return *TestData - 1;
  }

  return BehaviorTreeSpace::Prev;
}

int TestLargeOne2( void *Data )
{
  std::cout << "Right2" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  *TestData->SmallData = One;

  return BehaviorTreeSpace::Prev;
}

int TestLargeZero2( void *Data )
{
  std::cout << "Left2" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  *TestData->SmallData = Zero;

  return BehaviorTreeSpace::Prev;
}

int TestLargeOne1( void *Data )
{
  std::cout << "Right1" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  *TestData->SmallData = One;

  return BehaviorTreeSpace::Prev;
}

int TestLargeZero1( void *Data )
{
  std::cout << "Left1" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  *TestData->SmallData = Zero;

  return BehaviorTreeSpace::Prev;
}

int TestLargeOne0( void *Data )
{
  std::cout << "Right0" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  *TestData->SmallData = One;

  return BehaviorTreeSpace::Prev;
}

int TestLargeZero0( void *Data )
{
  std::cout << "Left0" << std::endl;

  auto TestData = static_cast< MediumData* >( Data );

  *TestData->SmallData = Zero;

  return BehaviorTreeSpace::Prev;
}

void LargeExample()
{
  auto TestDataSmallLeft = Two;
  auto TestDataSmallCenter = Two;
  auto TestDataSmallRight = Two;

  auto TestDataLarge = Three;

  MediumData TestDataMediumLeft = { &TestDataSmallLeft, &TestDataLarge };
  MediumData TestDataMediumCenter = { &TestDataSmallCenter, &TestDataLarge };
  MediumData TestDataMediumRight = { &TestDataSmallRight, &TestDataLarge };


  // Create Tree, comes with trunk
  BehaviorTreeSpace::BehaviorTree TestTree( LargeTestFunction, &TestDataLarge, 0 );


  // Add other data
  TestTree.AddData( &TestDataMediumLeft, 1 );
  TestTree.AddData( &TestDataMediumCenter, 2 );
  TestTree.AddData( &TestDataMediumRight, 3 );


  // Add first branch (ID 0) to the trunk with data 1
  TestTree.AddBranch( MediumLargeTestFunction, 1 );

  // Add second branch (ID 1) to the trunk with data 2
  TestTree.AddBranch( MediumLargeTestFunction, 2 );

  // Add third branch (ID 2) to the trunk with data 3
  TestTree.AddBranch( MediumLargeTestFunction, 3 );


  // Add first branch to branch 0 with data 1
  TestTree.AddBranch( TestLargeZero0, 1, { { 0 } } );

  // Add second branch to branch 0 with data 1
  TestTree.AddBranch( TestLargeOne0, 1, { { 0 } } );


  // Add first branch to branch 1 with data 2
  TestTree.AddBranch( TestLargeZero1, 2, { { 1 } } );

  // Add second branch to branch 1 with data 2
  TestTree.AddBranch( TestLargeOne1, 2, { { 1 } } );


  // Add first branch to branch 2 with data 3
  TestTree.AddBranch( TestLargeZero2, 3, { { 2 } } );

  // Add second branch to branch 2 with data 3
  TestTree.AddBranch( TestLargeOne2, 3, { { 2 } } );


  while( TestTree.RunBehaviorTree() );
}

void DynamicExample()
{
  InitTree();

  while( RunTree() )
  {
    std::cout << "Looping" << std::endl;
  } 

  ShutdownTree();
}

void MultiTreeExample()
{
  InitMultiTree();

  do
  {
    std::cout << "Looping" << std::endl;
  }
  while( RunMultiTree() );

  ShutdownMultiTree();
}

void MultiParentTreeExample()
{
  InitMultiParentTree();

  do
  {
    std::cout << "Looping" << std::endl;
  }
  while( RunMultiParentTree() );

  ShutdownMultiParentTree();
}

BehaviorTreeSpace::BehaviorTreePtr AutoGenerated();
BehaviorTreeSpace::BehaviorTreePtr AutoGen();

int main( )
{
  //std::cout << "StartLarge" << std::endl;

  //LargeExample();

  //std::cout << "StopLarge" << std::endl;

  //std::cout << std::endl;


  //std::cout << "StartDynamic" << std::endl;

  //DynamicExample();

  //std::cout << "StopDynamic" << std::endl;

  //std::cout << std::endl;


  //std::cout << "StartMultiTree" << std::endl;

  //MultiTreeExample();

  //std::cout << "StopMultiTree" << std::endl;

  //std::cout << std::endl;


  //std::cout << "StartAutoGeneratedTree" << std::endl;

  //{
  //  auto Tree = AutoGenerated();

  //  do
  //  {
  //    std::cout << "Looping" << std::endl;
  //  }
  //  while( Tree->RunBehaviorTree() );
  //}

  //std::cout << "StopAutoGeneratedTree" << std::endl;

  //std::cout << std::endl;


  //std::cout << "StartMultiParentTree" << std::endl;

  //MultiParentTreeExample();

  //std::cout << "StopMultiParentTree" << std::endl;

  //std::cout << std::endl;


  //std::cout << "StartAutoMultiParentTree" << std::endl;

  //{
  //  auto Tree = AutoGen();

  //  do
  //  {
  //    std::cout << "Looping" << std::endl;
  //  }
  //  while( Tree->RunBehaviorTree() );
  //}

  //std::cout << "StopAutoMultiParentTree" << std::endl;

  //std::cout << std::endl;


  return 0;
}
